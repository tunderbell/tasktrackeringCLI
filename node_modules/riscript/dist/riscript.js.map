{"version":3,"sources":["../src/riscript.js","../src/parser.js","../src/util.js","../src/visitor.js","../src/tokens.js","../src/grammar.js"],"sourcesContent":["/** @module riscript */\n\nimport he from 'he';\nimport { Query } from 'mingo';\nimport { Lexer } from 'chevrotain';\n\nimport { RiScriptParser } from './parser.js';\nimport { RiScriptVisitor } from './visitor.js';\nimport { getTokens, TextTypes } from './tokens.js';\nimport { RiGrammar } from './grammar.js';\nimport { Util } from './util.js';\n\nconst { decode } = he;\nconst Vowels = /[aeiou]/;\nconst HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\nconst { escapeText, slashEscToEntities, escapeMarkdownLink, escapeJSONRegex } = Util;\n\n/** @private */\nclass RiQuery extends Query {\n\n  constructor(scripting, condition, options) {\n\n    if (typeof condition !== 'string') {\n      try {\n        condition = JSON.stringify(condition);\n      }\n      catch (e) {\n        throw Error(condition.toString().includes('@') ?\n          'Replace @ with $ when passing an object to RiQuery\\nRoot: ' + e : e);\n      }\n    }\n\n    if (!condition.includes('$')) throw Error('Invalid Gate: \\''\n      + condition + \"' -> operand must include $symbol or $function()\");\n\n    condition = condition.replace(/(\\$|\\(\\))/g, '').replace(/@/g, '$');\n    condition = scripting.parseJSOL(condition);\n    \n    super(condition, options);\n  }\n\n  test(obj) {\n    // @ts-ignore\n    let compiled = this.compiled;\n    for (let i = 0, len = compiled.length; i < len; i++) {\n      if (!compiled[i](obj)) return false;\n    }\n    return true;\n  }\n\n  operands() {\n    // @ts-ignore\n    const stack = [this.condition];\n    const keys = new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        if (!key.startsWith('$')) keys.add(key);\n        if (typeof value === 'object' && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n}\n\n/**\n * The RiScript interpreter, responsible for lexing, parsing and evaluating \n * RiScript and RiGrammar expressions\n */\nclass RiScript {\n\n  /** @type {string} */\n  static VERSION = '1.1.1';\n\n  /** @type {typeof RiQuery} */\n  static Query = RiQuery;\n\n  /** @type {Object.<string, boolean>} */\n  static RiTaWarnings = { plurals: false, phones: false, silent: false };\n\n  /**\n   * Create a RiTa grammar instance\n   * @param {object} [rules] - the rules of the grammar\n   * @param {object} [context] - the context of the grammar\n   * @param {object} [options] - options for the evaluation\n   * @returns {RiGrammar} - a new RiGrammar instance\n   */\n  static grammar(rules, context, options) {\n    return new RiGrammar(rules, context, options);\n  }\n\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level (pass 2 for v2)\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation\n   * @returns {string} - the evaluated script\n   */\n  static evaluate(script, context, options = {}) {\n    return new RiScript(options).evaluate(script, context, options);\n  }\n\n  /**\n   * Creates a new RiScript instance\n   * @param {object} [options] - options for the object\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level\n   */\n  constructor(options = {}) {\n\n    /** @type {Object.<string, any>} */ this.Escaped = undefined\n    /** @type {Object.<string, string>} */ this.Symbols = undefined;\n\n    // created in evaluate() or passed as arg here\n    /** @type {RiScriptVisitor} */this.visitor = undefined;\n\n    /** @type {boolean} */ this.v2Compatible = (options.compatibility === 2);\n\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n\n    ({ Escaped: this.Escaped, Symbols: this.Symbols } = Constants);\n\n    this.pendingGateRe = new RegExp(`${this.Escaped.PENDING_GATE}([0-9]{9,11})`, 'g');\n\n    /** @type {string[]} */ this.textTypes = TextTypes;\n\n    /** @type {Object<string, any>} */ this.RiTa = options.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k)\n    }\n\n    /** @type {Object.<string, Function>} */\n    this.transforms = this._createTransforms();\n\n    /** @type {Object.<string, RegExp>} */\n    this.regex = this._createRegexes(tokens);\n\n    /** @type {Lexer} */\n    this.lexer = new Lexer(tokens);\n\n    /** @type {RiScriptParser} */\n    this.parser = new RiScriptParser(tokens, TextTypes);\n  }\n\n  /** @private */\n  lex(opts) {\n    if (!opts.input) throw Error('no input');\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error('Input: ' + opts.input + '\\n', lexResult.errors[0].message);\n      throw Error('[LEXING] ' + lexResult.errors[0].message);\n    }\n    if (opts.traceLex) this._printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n    // return lexResult;\n  }\n\n  /** @private */\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n\n  /** @private */\n  visit(opts) {\n    // @ts-ignore\n    return this.visitor.start(opts);\n  }\n\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @returns {string}\n   */\n  evaluate(script, context, options) {\n    if (typeof script !== 'string') {\n      throw Error('evaluate() expects a string, got ' + typeof script);\n    }\n    if (typeof options !== 'object') {\n      options = {};\n    }\n    options.input = script;\n    options.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(options);\n  }\n\n  /** @private */\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n\n  /**\n   * Add a transform function to this instance\n   * @param {string} name - the name of the transform\n   * @param {function} def - the transform function\n   * @returns {RiScript} this instance\n   */\n  addTransform(name, def) {\n    this.transforms[name] = def;\n    return this;\n  }\n\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return Object.keys(this.transforms);\n  }\n\n  /**\n   * Removes a transform function from this instance\n   * @param {string} name of transform to remove\n   * @returns {RiScript} this instance\n   */\n  removeTransform(name) {\n    delete this.transforms[name];\n    return this;\n  }\n\n  ///////////////////////////////////// End API //////////////////////////////////////\n\n  /**\n   * Private version of evaluate taking all arguments in the options object\n   * @param {object} options - options for the evaluation\n   * @param {string} options.input - the script to evaluate\n   * @param {object} options.visitor - the visitor to use for the evaluation\n   * @param {boolean} [options.trace] - whether to trace the evaluation\n   * @param {boolean} [options.onepass] - whether to only do one pass\n   * @param {boolean} [options.silent] - whether to suppress warnings\n   * @returns {string} - the evaluated script's output text\n   * @package\n   */\n  _evaluate(options) {\n\n    const { input, visitor, trace, onepass, silent } = options;\n\n    if (!input) throw Error('no input');\n    if (!visitor) throw Error('no visitor');\n\n    // onepass = true; // TMP\n\n    let last, endingBreak = this.regex.EndingBreak.test(input); // keep\n\n    let expr = this._preParse(input, options);\n    if (!expr) return '';\n\n    if (!options.visitor) throw Error('no visitor');\n    this.visitor = options.visitor;\n    delete options.visitor; // remind me why?\n\n    if (trace) {\n      console.log(`\\nInput:  '${escapeText(input)}' ctx=${visitor.lookupsToString()}`);\n      if (input !== expr) {\n        console.log(`Parsed: '${escapeText(expr)}'`);\n      }\n    }\n\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n\n      if (trace) console.log('-'.repeat(20)\n        + ' Pass#' + i + ' ' + '-'.repeat(20));\n\n      options.input = expr;\n      expr = this.lexParseVisit(options) ?? '';// do it\n      \n      if (trace) {\n        console.log(`Result(${i}) -> \"` + `${escapeText(expr||'')}\"`\n          + ` ctx=${this.visitor.lookupsToString()}`);\n      }\n\n      // end if no more riscript\n      if (onepass || !this.isParseable(expr)) break;\n    }\n\n    // check for unresolved symbols ([$#]) after removing HTML entities\n    if (!silent && !this.RiTa.SILENT) {\n      if (this.regex.ValidSymbol.test(expr.replace(HtmlEntities, ''))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"'\n          + expr.replace(/\\n/g, '\\\\n') + '\" ');\n      }\n    }\n\n    return this._postParse(expr, options) + (endingBreak ? '\\n' : '');\n  }\n\n  /** @private */\n  _printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === 'TEXT') tag = escapeText(t.image, true);\n      if (tag === 'Symbol') tag = 'sym(' + t.image + ')';\n      if (tag === 'TX') tag = 'tx(' + t.image + ')';\n      return str + tag + ', ';\n    }, '')\n      .slice(0, -2);\n    console.log('\\nTokens: [ ' + s + ' ]\\n');//  Context:', this.visitor.lookupsToString());\n  }\n\n  /** @private */\n  _preParse(script, opts) {\n    if (typeof script !== 'string') return '';\n\n    const $ = this.Symbols;\n\n    let input = script;\n    if (!this.v2Compatible) { // handle parenthesized weights\n      input = input.replace(this.regex.ParenthesizedWeights, '^$1^');\n    }\n\n    let matches = input.match(this.regex.MarkdownLinks); // md-links\n    matches && matches.forEach(m => input = input.replace(m, escapeMarkdownLink(m)));\n    input = input.replace(this.regex.MultiLineComments, ''); // multi-line comments\n    input = input.replace(this.regex.SingleLineComments, ''); // single-line comments\n    input = input.replace(this.regex.Continue, ''); // line continuations\n    input = slashEscToEntities(input); // double-backslashed escapes\n\n    let result = '';\n    let lines = input.split(this.regex.LineBreaks);\n    for (let i = 0; i < lines.length; i++) {\n\n      // special-case: handle assignments alone on a line\n      if (this.regex.RawAssign.test(lines[i])) {\n\n        // a very convoluted way of preserving line-breaks inside groups\n        let eqIdx = lines[i].indexOf('=');\n        if (eqIdx < 0) throw Error('invalid state: no assigment: ' + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx),\n          rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += '\\n' + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + '=' + rhs) + $.CLOSE_SILENT;\n\n      } else {\n\n        result += lines[i];\n        if (i < lines.length - 1) result += '\\n';\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates a new RiQuery object from the raw query string\n   * @package \n   */\n  createQuery(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n\n  /** @private */\n  _postParse(input, opts) {\n    if (typeof input !== 'string') return '';\n\n    //console.log('_postParse \"' + input + '\"', opts);\n\n    // replace html entities\n    let decoded = decode(input);\n\n    // clean up whitespace, linebreaks\n    let result = decoded\n      .replace(this.regex.Whitespace, ' ')\n      .replace(this.regex.EndingBreak, '');\n\n    // handle unresolved gates\n    let gates = [...result.matchAll(this.pendingGateRe)];\n    //console.log(result, result.length, this.pendingGateRe.toString(), [...result.matchAll(this.pendingGateRe)]);\n    if (opts.trace && gates.length) {\n      console.log('-'.repeat(20) + ' pGates ' + '-'.repeat(20));\n    }\n    this.visitor.order = 0;\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1]) throw Error('bad gate: ' + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      if (!deferredGate) throw Error('no deferredGate: ' + g[1]);\n      let { deferredContext, operands, gateText } = deferredGate;\n      if (!operands.length) throw Error('no operands');\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n      result = result.replace(g[0], reject);\n      if (opts.trace) console.log('Unresolved gate: \\'' + gateText + '\\' {reject}');\n    });\n\n    if (opts.trace) console.log(`\\nFinal: '${result}'`);\n\n    if (!opts.preserveLookups) {\n      // reset lookups unless preserveLookups=true (for testing only)\n      this.visitor.statics = undefined;\n      this.visitor.dynamics = undefined;\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a mingo query into JSON format\n   * @package\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text) => {\n      const RegexEscape = Util.RegexEscape\n      // TODO: why do we need this?\n      let res = text;\n      if (\n        typeof text === 'string' &&\n        text.startsWith(RegexEscape) &&\n        text.endsWith(RegexEscape)\n      ) {\n        let parts = text.split(RegexEscape);\n        if (parts.length !== 4) throw Error('invalid regex in unescape');\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = escapeJSONRegex(text)\n      .replace(this.regex.JSOLIdent, '\"$1\":')\n      .replace(/'/g, '\"');\n\n    // console.log(\"escaped: '\"+escaped+\"'\");\n\n    let result = JSON.parse(escaped), urp = unescapeRegexProperty;\n\n    Object.keys(result).forEach((k) => (result[k] = urp(result[k])));\n\n    return result;\n  }\n\n  /**\n   * True if input contains parseable script\n   * @private\n   */\n  isParseable(s) {\n    // conservatively assume non-string/numbers are always parseable\n    // otherwise, if a string or num, test for special chars\n    let result = true;\n    if (typeof s === 'number') {\n      s = s.toString();\n    }\n    if (typeof s === 'string') {\n      result = this.regex.Special.test(s) || s.includes(this.Symbols.PENDING_GATE)\n      // || this.pendingGateRe.test(s);\n    }\n    return result;\n  }\n\n  // ========================= statics ===============================\n\n  /**\n   * Default transform that pluralizes a string (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [pluralizer] - custom pluralizer with pluralize() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static pluralize(s, pluralizer) {\n    if (!pluralizer?.pluralize) {\n      if (!RiScript.RiTaWarnings.plurals && !RiScript.RiTaWarnings.silent) {\n        RiScript.RiTaWarnings.plurals = true;\n        console.warn('[WARN] Install RiTa for proper pluralization');\n      }\n      return s.endsWith('s') ? s : s + 's';\n    }\n    return pluralizer.pluralize(s);\n  }\n\n  /**\n   * Default transform that adds an article (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [phonemeAnalyzer] - custom phoneme analyzer with phones() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static articlize(s, phonemeAnalyzer) {\n    if (!s || !s.length) return '';\n\n    let first = s.split(/\\s+/)[0];\n\n    if (!phonemeAnalyzer?.phones) {\n      if (!RiScript.RiTaWarnings.phones && !RiScript.RiTaWarnings.silent) {\n        console.warn('[WARN] Install RiTa for proper phonemes');\n        RiScript.RiTaWarnings.phones = true;\n      }\n      // first.startsWith('a') ? 'an ' : 'a ') + s;\n      return (/^[aeiou].*/i.test(first) ? 'an ' : 'a ') + s;\n    }\n\n    let phones = phonemeAnalyzer.phones(first, { silent: true });\n\n    // could still be original word if no phones found\n    return ((phones?.length && Vowels.test(phones[0]) ? 'an ' : 'a ') + s);\n  }\n\n  /**\n   * Default transform that uppercases the first character of the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : '';\n  }\n\n  /**\n   * Default transform that capitalizes the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static uppercase(s) {\n    return s ? s.toUpperCase() : '';\n  }\n\n  /**\n   * Default transform that wraps the string in (smart) quotes.\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static quotify(s) {\n    return '&#8220;' + (s || '') + '&#8221;';\n  }\n\n  /**\n   * Default no-op transform\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static identity(s) {\n    return s;\n  }\n\n    // ========================= helpers ===============================\n\n  /** @private */\n  _createRegexes(tokens) {\n\n    const Esc = this.Escaped;\n    const open = Esc.OPEN_CHOICE;\n    const close = Esc.CLOSE_CHOICE;\n    const anysym = Esc.STATIC + Esc.DYNAMIC;\n\n    return {\n      LineBreaks: /\\r?\\n/,\n      EndingBreak: /\\r?\\n$/,\n      NonGateAtSigns: /([^}])@(?!{)/,\n      AnySymbol: new RegExp(`[${anysym}]`),\n      ParenthesizedWeights: /\\(\\s*(\\d+)\\s*\\)/g, // TODO: change for negative weights\n      MultiLineComments: /\\/\\*[^]*?(\\r?\\n)?\\//g,\n      SingleLineComments: /\\/\\/[^\\n]+(\\r?\\n|$)/g,\n      MarkdownLinks: /\\[([^\\]]+)\\]\\(([^)\"]+)(?: \\\"([^\\\"]+)\\\")?\\)/g,\n      RawAssign: new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`),\n      JSOLIdent: new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, 'g'),\n      ChoiceWrap: new RegExp('^' + open + '[^' + open + close + ']*' + close + '$'),\n      ValidSymbol: new RegExp('(' + Esc.DYNAMIC + '|' + Esc.STATIC + '[A-Za-z_0-9])[A-Za-z_0-9]*'),\n      Entity: tokens.filter(t => t.name === 'Entity')[0].PATTERN,\n      StaticSymbol: new RegExp(Esc.STATIC + '[A-Za-z_0-9][A-Za-z_0-9]*'),\n      Special: new RegExp(`[${Esc.SPECIAL.replace('&', '')}]`),\n      Continue: new RegExp(Esc.CONTINUATION + '\\\\r?\\\\n', 'g'),\n      Whitespace: /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g,\n    };\n  }\n\n  /** @private */\n  _createTransforms() {\n    let transforms = {\n      quotify: (w) => RiScript.quotify(w),\n      pluralize: (w) => RiScript.pluralize(w, this.RiTa),\n      articlize: (w) => RiScript.articlize(w, this.RiTa),\n      capitalize: (w) => RiScript.capitalize(w),\n      uppercase: (w) => RiScript.uppercase(w),\n      norepeat: (w) => RiScript.identity(w),\n    };\n\n    // aliases\n    transforms.art = transforms.articlize;\n    transforms.nr = transforms.norepeat;\n    transforms.cap = transforms.capitalize;\n    transforms.uc = transforms.uppercase;\n    transforms.qq = transforms.quotify;\n    transforms.s = transforms.pluralize;\n    transforms.ucf = transforms.capitalize; // @dep\n\n    return transforms;\n  }\n}\n\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c) count++;\n  }\n  return count;\n}\n\n// Class ref hacks for testing\nRiScript.Visitor = RiScriptVisitor;\nRiScript.Util = Util;\n\nexport { RiScript };","// @ts-nocheck\nimport { CstParser } from \"chevrotain\"\n\n/**\n * RiScriptParser\n * @class\n * @memberof module:riscript\n */\nclass RiScriptParser extends CstParser {\n\n  constructor(allTokens, textTypes) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = ['silent', 'assign', 'symbol', 'choice', 'pgate', 'text', 'entity'];\n    this.textTypes = textTypes; // defined in tokens.js\n    this.buildRules();\n  }\n\n  parse(opts) {\n    this.input = opts.tokens; // superclass member (dont change)\n\n    let cst = this.script();\n    if (this.errors.length > 0) throw Error\n      (\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n\n  /*\n    Specification:\n      script: expr+\n      expr: atom+\n      atom: (choice | symbol | text | silent | entity | pgate | assign)\n      wexpr: (expr | Weight)*\n      symbol: Symbol transform*\n      choice: [ gate? orExpr elseExpr? ] transform*\n      assign: Symbol EQ expr\n      silent: { gate? (symbol | assign) }\n      orExpr: wexpr (OR wexpr)*\n      elseExpr: ELSE orExpr\n      pgate: PGate\n      entity: Entity\n      gate: Mingo\n      text: Raw | STAT | AMP \n  */\n  buildRules() {\n\n    const $ = this, Tokens = this.tokensMap;\n\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map(t => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) },\n        ])\n      });\n    });\n\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    // choice: (LP (wexpr OR)* wexpr RP) transform*;\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC)\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.orExpr)\n      $.OPTION2(() => {\n        $.SUBRULE2($.elseExpr)\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.Symbol);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n\n    $.RULE(\"orExpr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n\n    $.RULE(\"elseExpr\", () => {\n      $.CONSUME(Tokens.ELSE);\n      $.SUBRULE($.orExpr);\n    });\n\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n      //$.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n\n    $.RULE(\"gate\", () => {\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n    });\n\n    $.RULE(\"text\", () => {\n      $.OR(this.textTypes.map(t => ({ ALT: () => $.CONSUME(Tokens[t]) })));\n    });\n\n    this.performSelfAnalysis(); // keep\n  }\n}\n\nexport { RiScriptParser };","/**\n * @memberof module:riscript\n */\nclass Util {\n\n  ///////////////////////// CONSTANTS /////////////////////////\n\n\n  /**\n   * @static\n   * @memberof Util\n   * @package\n   */\n  static RegexEscape = '_RE_';\n\n  ///////////////////////// FUNCTIONS /////////////////////////\n\n  static formatAny(o) {\n    if (typeof o === 'string') return `'${o}'`;\n    else if (typeof o === 'number') return o;\n    if (typeof o === 'function') throw Error('unexpected function');\n    return JSON.stringify(o).replace(/\"/g, '');\n  }\n\n  static transformNames(txs) {\n    return txs && txs.length\n      ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, ''), [])\n      : [];\n  }\n\n  static escapeText(s, quotify) {\n    if (typeof s !== 'string') return Util.formatAny(s);\n    let t = s.replace(/\\r?\\n/g, '\\\\n');\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n\n  static stringHash(s) { // for testing\n    let chr,\n      hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n    let strHash = hash.toString().padStart(9, '0');\n    return hash < 0 ? strHash.replace('-', '0') : strHash;\n  }\n\n  static escapeMarkdownLink(txt) {\n    let result = txt;\n    let lookups = { '[': '&lsqb;', ']': '&rsqb;', '(': '&lpar;', ')': '&rpar;', '/': '&sol;' };\n    Object.entries(lookups).forEach(([k, v]) => result = result.replace(new RegExp(`\\\\${k}`, 'g'), v));\n    return result;\n  }\n\n  static slashEscToEntities(s) {\n    s = Util.replaceAll(s, '\\\\(', '&lpar;');\n    s = Util.replaceAll(s, '\\\\)', '&rpar;');\n    s = Util.replaceAll(s, '\\\\[', '&lsqb;');\n    s = Util.replaceAll(s, '\\\\]', '&rsqb;');\n    s = Util.replaceAll(s, '\\\\{', '&lcqb;');\n    s = Util.replaceAll(s, '\\\\}', '&rcqb;');\n    s = Util.replaceAll(s, '\\\\@', '&commat;');\n    s = Util.replaceAll(s, '\\\\#', '&num;');\n    s = Util.replaceAll(s, '\\\\|', ' &vert');\n    s = Util.replaceAll(s, '\\\\=', ' &equals');\n    return s;\n  }\n\n  static escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${Util.RegexEscape}$1${Util.RegexEscape}$2${Util.RegexEscape}\"`\n    );\n  }\n\n  static escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  }\n\n  static replaceAll(str, match, replacement) {\n    return str.replace(new RegExp(Util.escapeRegExp(match), 'g'), () => replacement);\n  }\n\n}\n\nexport { Util };","/** @module riscript */\n\nimport { Util } from './util.js';\n\nconst { escapeText, stringHash, formatAny, transformNames } = Util;\n\n/**\n * @class\n * @memberof module:riscript\n */\nclass BaseVisitor {\n  constructor(riScript) {\n    /**@type {string}*/this.input = '';\n    /**@type {boolean}*/this.nowarn = false;\n    /**@type {boolean}*/this.tracePath = true;\n    /**@type {object}*/this.scripting = riScript;\n    /**@type {boolean}*/this.warnOnInvalidGates = false;\n    /**@type {number}*/this.maxRecursionDepth = 10;\n  }\n\n  textFromCstNode(node) {\n    if (Array.isArray(node)) node = node[0];\n    return this.input.substring(\n      node.location.startOffset,\n      node.location.endOffset + 1\n    );\n  }\n\n  isCstNode(o) {\n    if (Array.isArray(o)) o = o[0];\n    return (typeof o === 'object' && ('accept' in o\n      || ('name' in o && 'location' in o && 'children' in o)));\n  }\n\n  visit(cstNode, options) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === 'undefined') {\n      return undefined;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error('Non-cstNode passed to visit: ' + JSON.stringify(cstNode));\n    }\n    this.nodeText = this.textFromCstNode(cstNode); // remove\n\n    const name = cstNode.name;\n    if (typeof this[name] !== 'function') {\n      throw Error('BaseVisitor.visit: expecting function for this[' +\n        `${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n    return this[name](cstNode.children, options);\n  }\n\n  validateVisitor() { /* no-op */ }\n}\n\n/**\n * @class\n * @memberof module:riscript\n */\nclass RiScriptVisitor extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript);\n\n    this.order = 0;\n    this.trace = 0;\n    this.indent = 0;\n    this.choices = {};\n    this.context = context;\n    this.isNoRepeat = false;\n\n    this.Symbols = this.scripting.Symbols;\n    this.Escaped = this.scripting.Escaped;\n\n    // lookups\n    this.statics = {}; // store static symbols as values, set once and re-used\n    this.dynamics = {}; // store dynamic symbols as functions to be re-evaluated each time\n    this.pendingGates = {}; // store gates for which operands are not resolved\n\n    this.validateVisitor(); // keep\n  }\n\n  start(opts = {}) {\n\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.nowarn = opts.silent;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst) throw Error('no cst');\n    return super.visit(opts.cst);\n  }\n\n  script(ctx) {\n    this.order = this.indent = 0;\n    if (Object.keys(ctx).length !== 1) throw Error('script: invalid expr');\n    let count = ctx.expr[0].children.atom.length;\n    this.print('script', `'${escapeText(this.input)}' :: ${count} atom(s)`);\n    if (!count) return '';\n    this.indent++;\n    let value = this.visit(ctx.expr);\n    this.indent--;\n    this.print('/script');\n    return value;\n  }\n\n  expr(ctx) {\n    // this.print('expr', ctx);\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid expr: ' + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c)); // collect each atom\n\n    if (exprs.length === 1) return exprs[0];\n\n    // handle special cases of the form: \"not [quite|] far enough\"\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (exprs[i].length === 0 &&\n        exprs[i - 1].endsWith(' ') &&\n        exprs[i + 1].startsWith(' ')) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join('');\n  }\n\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1) throw Error('invalid atom: ' + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      if (ctx[type]) {\n        if (ctx[type].length !== 1) {\n          throw Error(type + ': bad length -> ' + ctx[type].length);\n        }\n        result = this.visit(ctx[type][0]);\n        // pending function, call it\n        if (typeof result === 'function') {\n          result = result.call();\n        }\n      }\n    });\n    return result;\n  }\n\n  silent(ctx) {\n    this.print('silent', this.nodeText);\n    this.indent++;\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    this.indent--;\n    this.print('/silent', 'statics=' + formatAny(this.statics));\n\n    return '';\n  }\n\n  assign(ctx, opts) {\n\n    const sym = ctx.Symbol[0].image;\n    const original = this.nodeText;\n    const ident = sym.replace(this.scripting.regex.AnySymbol, '');\n    const isStatic = sym.startsWith(this.Symbols.STATIC);\n    const isSilent = opts?.silent;\n\n    let info = `${original} ${isStatic && isSilent ? '{#static,silent}' :\n      (isStatic ? '{#static}' : '') + (isSilent ? '{silent}' : '')}`;\n    this.print('assign', info);\n\n    let value;\n    if (isStatic) { // static: store as value, set once and re-use\n\n      if (ident in this.statics && !this.scripting.isParseable(this.statics[ident])) {\n        value = this.statics[ident];\n        info = `${sym} = ${formatAny(value)} {#resolved}`;\n      }\n      else {\n        // TODO: move indent++/-- to visit() ?\n        this.indent++;\n        value = this.visit(ctx.expr); // visit the right-hand side\n        this.indent--;\n\n        this.statics[ident] = value;  // store in lookup table, resolved or not\n\n        if (typeof value === 'string' && this.scripting.isParseable(value)) {\n          value = this.inlineStaticAssign(ident, ctx.Transform, value);\n        }\n        info = `${sym} = ${formatAny(value)}`;\n      }\n      this.print('/assign', info);\n    } else {\n      const $ = this;\n\n      // dynamic: store as func to be resolved later, perhaps many times\n      // OPT: check if parseable. if not, remove the function and use the value directly?\n      this.indent++;\n      value = () => $.visit(ctx.expr); // the right-hand side\n      this.indent--;\n\n      // NOTE: this function may contain a choice, which needs to be handled\n      // when called from a symbol with a norepeat transform (??) TODO: test\n\n      this.dynamics[ident] = value; // store in lookup table\n      this.print('/assign', `${sym} =  <f*:pending>`);\n    }\n\n    return value;\n  } // end assign\n\n  symbol(ctx, opts) {\n    if (ctx.Symbol.length !== 1) throw Error('[1] invalid symbol');\n\n    const isSilent = opts?.silent;\n    const original = this.nodeText;\n    const sym = ctx.Symbol[0].image.replace(/\\(\\)$/, '');\n    const ident = sym.replace(this.scripting.regex.AnySymbol, '');\n    this.isNoRepeat = this.hasNoRepeat(ctx.Transform);\n\n    this.print('symbol', `${original} ${isSilent ? ' {silent}' : ''}`);\n\n    // lookup: result is either a value, a function, or undef\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n\n    if (!isStatic && this.scripting.regex.StaticSymbol.test(sym)) {\n      if (!this.scripting.regex.Entity.test(sym)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as` +\n          ` ${this.Symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n\n    // if we have a function, call it here (potentially many times)\n    for (let i = 0; typeof result === 'function'; i++) {\n      result = result.call();\n      resolved = !this.scripting.isParseable(result);\n      if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n    }\n\n    // check for norepeat on a non-dynamic symbol and throw if found\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = 'Attempt to call norepeat() on ' + (isStatic\n        ? \"static symbol '\" + sym + \"'. Did you mean to use '\" +\n        this.Symbols.DYNAMIC + ident + \"' ?\"\n        : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" +\n        this.Symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n\n    // nothing found thus far, so defer for now\n    if (typeof result === 'undefined') {\n      this.print('/symbol', sym + \" -> '\" + original + \"' ctx=\" +\n        this.lookupsToString(), '[deferred]', opts?.silent ? '{silent}' : '');\n      return original;\n    }\n\n    let info = opts?.trace ? `${original.replace(/\\(\\)$/, '')} -> ${formatAny(result)}`\n      + (opts?.silent ? ' {silent}' : '') : null; // for logging\n\n    // also defer if we still have unresolved script\n    if (typeof result === 'string' && !resolved) {\n      if (isStatic) {\n        result = this.inlineStaticAssign(ident, ctx.Transform, result);\n        this.print('/symbol', `${original} -> ${result}`);// :: pending.add(${ident})`);\n      } else {\n        if (ctx.Transform) result = this.restoreTransforms(result, ctx.Transform);\n        this.print('/symbol', info);\n      }\n      return result;\n    }\n\n    // store untransformed result in static context\n    if (isStatic) this.statics[ident] = result; // ADDED 8/18/23, FIXED 10/8/23\n\n    // finally, apply any transforms\n    if (ctx.Transform) {\n      result = this.applyTransforms(result, ctx.Transform);\n      info += \"-> '\" + result + \"'\";\n      if (this.isNoRepeat) info += ' (norepeat)';\n    }\n    else if (result.length === 0 && sym.length === 1) {\n      // this is a raw $, without transform, keep it DCH: 1/21/24\n      result = sym;\n      info = '** $ **';\n    }\n\n    this.print('/symbol', info);\n    this.isNoRepeat = false; // reset\n\n    return result;\n  } // end symbol\n\n  choice(ctx, opts) {\n    const $ = this.Symbols;\n    const original = this.nodeText;\n    const choiceKey = stringHash(original + ' #' + this.choiceId(ctx));\n\n    let gateText, gateResult, hasTransforms = ctx.Transform;\n\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.Transform)) {\n      throw Error('noRepeat() not allowed on choice '\n        + '(use a $variable instead): ' + original);\n    }\n\n    this.print('choice', original);\n\n    let decision = 'accept';\n    if (opts?.forceReject) {\n      decision = 'reject';\n    } else {\n      // TODO: make function -> handleGate(ctx) returns \n      //    { decision: [accept|reject] } or { decision: 'defer', pgateValue }\n      let gateCtx = ctx?.gate?.[0]?.children?.Gate;\n      if (gateCtx) {\n        // do we have a gate?\n        gateText = gateCtx[0].image;\n        this.indent++;\n        gateResult = this.visit(ctx.gate);\n        this.indent--;\n        decision = gateResult.decision;\n        let ginfo = `${gateText} -> ${(decision !== 'defer' ? decision.toUpperCase()\n          : `DEFER ${$.PENDING_GATE}${choiceKey}`)}  ${this.lookupsToString()}`;\n        this.print('gate', ginfo);\n      }\n\n      if (gateResult && gateResult.decision === 'defer') {\n        this.pendingGates[choiceKey] = {\n          gateText,\n          deferredContext: ctx,\n          operands: gateResult.operands\n        };\n        return `${$.PENDING_GATE}${choiceKey}`; // gate defers\n      }\n    }\n\n    let orExpr = ctx?.orExpr[0];\n    if (decision === 'reject') {\n      if (!('elseExpr' in ctx)) return ''; // rejected without else\n      orExpr = ctx.elseExpr[0].children.orExpr[0];\n    }\n\n    const options = this.parseOptions(orExpr); // get options\n    if (!options) throw Error('No options in choice: ' + original);\n\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded);\n\n      // while we have a cstNode, visit it\n      for (let i = 0; this.isCstNode(value); i++) {\n        this.indent++;\n        value = this.visit(value); // visit the node\n        this.indent--;\n        if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n      }\n\n      if (typeof value === 'string') {\n        value = value.trim();\n      }\n      else if (typeof value !== 'number') { // some type of complex object\n        if (ctx.Transform) value = this.applyTransforms(value, ctx.Transform);\n        hasTransforms = false; // applied the transform so don't do it again later;\n      }\n\n      // if we still have script, defer until its resolved\n      if (this.scripting.isParseable(value)) {\n        if (ctx.Transform) value = this.restoreTransforms(value, ctx.Transform);\n        restored = true;\n        break;\n      }\n\n      // apply any remaining transforms\n      if (hasTransforms) value = this.applyTransforms(value, ctx.Transform);\n\n      // we have 'norepeat' but value was already used, try again\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print('choice-reject', value + ' [norepeat]');\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n\n    if (!restored) this.choices[choiceKey] = value; // put in choice cache\n    this.print('choice/', original + ' -> \\'' + value + '\\'');\n\n    return value;\n  } // end choice\n\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error('Invalid choice: no options');\n    }\n    const valid = options.filter(x => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error('Invalid choice: no valid options');\n    }\n    const index = this.scripting.RiTa.randi(valid.length);\n    let value = valid[index];\n    return value;\n  }\n\n  text(ctx) {\n    if (Object.keys(ctx).length !== 1) throw Error('[2] invalid text');\n    const type = this.scripting.textTypes.filter(t => ctx[t]);\n    const image = ctx[type][0].image; // any of riscript.textTypes\n    this.print('text/', escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n\n  entity(ctx) {\n    return this.nodeText;\n  }\n\n  gate(ctx) {\n    // returns { decision: [accept|reject] } or { decision: 'defer', operands: [] }\n\n    if (ctx.Gate.length !== 1) throw Error('Invalid gate: ' + ctx.Gate);\n\n    let raw = ctx.Gate[0].image, mingoQuery;\n    if (raw.startsWith(this.Symbols.OPEN_GATE)) {\n      raw = raw.substring(1);\n    }\n    try {\n      mingoQuery = this.scripting.createQuery(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}\"\\n\\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.nowarn) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\\n`, e);\n      }\n      return { decision: 'accept' };\n    }\n\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result, resolved, isStatic, isUser } = this.checkContext(sym);\n\n      for (let i = 0; typeof result === 'function'; i++) {\n        result = result.call(); // call it\n        resolved = !this.scripting.isParseable(result);\n        if (i === this.maxRecursionDepth) throw Error('Max recursion depth reached');\n      }\n\n      if (typeof result === 'undefined' || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        // add to appropriate context\n        if (isStatic) {\n          this.statics[sym] = result;\n        } else if (isUser) {\n          this.context[sym] = result;\n        } else {\n          this.dynamics[sym] = result;\n        }\n        // store resolved result\n        resolvedOps[sym] = result;\n      }\n    });\n\n    if (Object.keys(resolvedOps).length + unresolvedOps.length !== operands.length) {\n      throw Error('invalid operands');\n    }\n\n    // if we have unresolved operands, return them (and defer)\n    if (unresolvedOps.length) {\n      return { decision: 'defer', operands: unresolvedOps };\n    }\n\n    let result = mingoQuery.test(resolvedOps); // do test\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps); // redo test after casting\n    }\n\n    return { decision: result ? 'accept' : 'reject' };\n  }\n\n  pgate(ctx) {\n    this.print('pgate', this.nodeText);\n\n    const original = this.nodeText;\n    const ident = original.replace(this.Symbols.PENDING_GATE, '');\n    const lookup = this.pendingGates[ident];\n\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' +\n        JSON.stringify(Object.keys(this.pendingGates)));\n    }\n\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === 'function') {\n        // while {} ?\n        // let tracing = this.trace;\n        // this.trace = false; // disable tracing\n        result = result.call(); // call it\n        //this.trace = tracing;\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === 'undefined' || !resolved;\n    });\n\n    if (stillUnresolved) return original; // still deferred\n\n    return this.choice(lookup.deferredContext); // execute the gate\n  }\n\n  else(ctx) {\n    // this.print('else', this.nodeText);\n    return this.visit(ctx.expr).trim();\n  }\n\n\n  // Helpers ================================================\n\n  hasNoRepeat(tfs) {\n    const transforms = transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes('nr') || transforms.includes('norepeat');\n    }\n    return false;\n  }\n\n  checkContext(ident, opts = {}) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n\n    // empty symbol, just return\n    if (ident.length === 0) { \n      return { result: '', resolved: true, isStatic, isUser };\n    }\n\n    // check for dynamic symbol: $var\n    result = this.dynamics[ident];\n    if (typeof result === 'undefined') {\n      // no dynamic, check for static symbol: #var\n      result = this.statics[ident];\n      if (typeof result !== 'undefined') {\n        isStatic = true; // found static\n      }\n    }\n\n    if (typeof result === 'undefined') {\n      // no static, check for user-defined symbol: context[var]\n      result = this.context[ident];\n      if (typeof result !== 'undefined') {\n        isUser = true; // found user symbol\n      } \n    }\n\n    if (typeof result === 'undefined') {\n      // last option: check for bare transform: $var()\n      result = this.scripting.transforms[ident];\n    }\n\n    // do we have more script to deal with ?\n    const resolved = !this.scripting.isParseable(result);\n\n    return { result, isStatic, isUser, resolved }; // TODO: replace with 'type'\n  }\n\n  inlineStaticAssign(ident, tfs, result) {\n    const $ = this.Symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = result;\n    let stmt = $.OPEN_CHOICE + (lhs + '=' + rhs) + $.CLOSE_CHOICE;\n    result = this.restoreTransforms(stmt, tfs);\n    return result;\n  }\n\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length) throw Error('invalid choice');\n    return ctx.OC[0].startOffset + '.' + ctx.OC[0].endOffset;\n  }\n\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) { throw Error('invalid choice-expr: ' + expr.length); }\n\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) { throw Error('invalid weight: ' + weight.length); }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.Symbols.CLOSE_WEIGHT.length\n                ? weight[0].image.trim().slice(1, -1)\n                : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log('EX: ' + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || '');\n        }\n      }\n    }\n    return options;\n  }\n\n  applyTransforms(value, txs) {\n    this.indent++;\n    if (this.traceTx) { console.log('applyTransforms', this.formatTxs(...arguments)); }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    this.indent--;\n    return value;\n  }\n\n  applyTransform(target, transform) {\n\n    const image = transform.image;\n    const raw = target + image;\n    const original = formatAny(target) + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, '');\n    const RiTa = this.scripting.RiTa;\n\n    let result;\n\n    // function in dynamics\n    if (typeof this.dynamics[tx] === 'function') {\n      result = this.dynamics[tx].bind(this.context)(target);\n    }\n    // function in statics\n    else if (typeof this.statics[tx] === 'function') {\n      result = this.statics[tx].call(this.context, target);\n    }\n    // function in context\n    else if (typeof this.context[tx] === 'function') {\n      result = this.context[tx].call(this.context, target);\n    }\n    // function in transforms\n    else if (typeof this.scripting.transforms[tx] === 'function') {\n      result = this.scripting.transforms[tx].call(this.context, target);\n    }\n    // member functions (usually on String)\n    else if (typeof target[tx] === 'function') {\n      result = target[tx]();// .call() ?\n    } else {\n      // check for property\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!RiTa.SILENT && !this.silent) {\n          console.warn('[WARN] Unresolved transform: ' + raw);\n        }\n\n        /* Replace transform parens so as not to trigger\n           RiScript.isParseable (for example, in v2) 0 */\n        result = raw.replace(/\\(\\)$/, '&lpar;&rpar;');\n      }\n    }\n\n    this.print('transform/', `${original} -> '${result}'`);\n\n    return result;\n  }\n\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === 'string') {\n      const choiceRE = new RegExp('^' + this.Escaped.OPEN_CHOICE + '.*' + this.Escaped.CLOSE_CHOICE + '$');\n      const symbolRE = new RegExp(`(${this.Escaped.DYNAMIC}|${this.Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*`);\n      if (!choiceRE.test(value) && !symbolRE.test(value)) {\n        // wrap in choice to preserve\n        value = this.Symbols.OPEN_CHOICE + value + this.Symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => (value += tx.image)); // append transform strings\n      }\n      if (this.traceTx) console.log('restoreTransforms:', value);\n    }\n    return value;\n  }\n\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num; // update object with casted value\n      }\n    });\n    return madeCast;\n  }\n\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n\n  lookupsToString() {\n    const dyns = {}, stats = {};\n    Object.entries(this.dynamics || {}).forEach(([k, v]) => (dyns[`$${k}`] = v));\n    Object.entries(this.statics || {}).forEach(([k, v]) => (stats[`#${k}`] = v));\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) =>\n      typeof v === 'function' ? '<f*:pending>' : v).replace(/\"/g, '');\n  }\n\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, '') + '()').join('');\n  }\n\n  print(s, ...args) {\n    if (this.trace) {\n      let indentStr = '  '.repeat(this.indent);\n      let msg = `${indentStr}<${s}>${s.startsWith('/') ? '' : ' '}`;\n      if (++this.order < 10) msg = ' ' + msg;\n      console.log(this.order, msg, ...args);\n    }\n  }\n}\n\nexport { RiScriptVisitor };","/**\n * @memberof module:riscript\n */\nimport { createToken } from \"chevrotain\"\n\nfunction getTokens(v2Compatible) {\n\n  let Symbols = {\n    OR: '|',\n    ELSE: '||',\n    DYNAMIC: '$',\n    STATIC: '#',\n    ENTITY: '&',\n    OPEN_GATE: '@',\n    PENDING_GATE: '@@',\n    OPEN_SILENT: '{',\n    CLOSE_SILENT: '}',\n  };\n\n  let v2Symbols = {\n    OPEN_CHOICE: '(',\n    CLOSE_CHOICE: ')',\n    OPEN_WEIGHT: '[',\n    CLOSE_WEIGHT: ']',\n    CONTINUATION: '\\\\',\n  };\n\n  let v3Symbols = {\n    OPEN_CHOICE: '[',\n    CLOSE_CHOICE: ']',\n    OPEN_WEIGHT: '^', // also allows (int), eg. (3)\n    CLOSE_WEIGHT: '^',\n    CONTINUATION: '~',\n  };\n\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => { Escaped[k] = escapeRegex(v) });\n\n  const ENTITY_PATTERN = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i;\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`)\n\n  Escaped.SPECIAL = Object.values(Escaped).join('').replace(/[<>@]/g, ''); // allow <> for html, @ for md-links\n\n  const DYN = createToken({ name: \"DYN\", pattern: new RegExp(Escaped.DYNAMIC) });\n  const STAT = createToken({ name: \"STAT\", pattern: new RegExp(Escaped.STATIC) });\n  const OC = createToken({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + '\\\\s*') });\n  const CC = createToken({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OS = createToken({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = createToken({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const ELSE = createToken({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const OR = createToken({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const EQ = createToken({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const AMP = createToken({ name: \"AMP\", pattern: /&/ });\n\n  // Group placement allows for bare $ symbols here\n  const Symbol = createToken({ name: \"Symbol\", pattern: new RegExp(`(${Escaped.DYNAMIC}|${Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*(\\\\(\\\\))?`) });\n  const Transform = createToken({ name: \"Transform\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const Entity = createToken({ name: \"Entity\", pattern: ENTITY_PATTERN });\n  const Weight = createToken({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}\\\\d+${Escaped.CLOSE_WEIGHT}\\\\s*`) }); // TODO: change for negative weights\n  const PendingGate = createToken({ name: \"PendingGate\", pattern: PENDING_GATE_PATTERN });\n  const Raw = createToken({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n\n  // @ts-ignore\n  const Gate = createToken({ name: \"Gate\", line_breaks: true, pattern: bracketMatch });\n\n  const tokens = [Gate, Entity, Weight, ELSE, OC, CC, OR, EQ, Symbol, DYN, STAT, AMP, Transform, OS, CS, PendingGate, Raw];\n\n  return { tokens, Constants: { Symbols, Escaped } };\n}\n\nfunction bracketMatch(text, startOffset) {\n\n  if (!/^@/.test(text.substring(startOffset))) return null;\n\n  let endOffset = startOffset + 1;\n\n  let dbug = 0;\n  if (dbug) console.log('bracketMatch', text);\n  let charCode = text.charCodeAt(endOffset);\n\n  // spaces between the @ and the open brace \n  while (charCode === 32) {\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n  if (charCode !== 123) { // 123 = '{'\n    if (dbug) console.log(`  \"${text.substring(startOffset, endOffset)}\" -> null1`);\n    return null;\n  }\n  endOffset++;\n  charCode = text.charCodeAt(endOffset);\n  let depth = 1;\n  while (depth > 0) {\n    if (charCode === 123) depth++; // 123 = '{'\n    else if (charCode === 125) depth--; // 123 = '}'\n    if (dbug) console.log('  depth', depth, text.substring(startOffset, endOffset));\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n\n  // No match, must return null xsto conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    if (dbug) console.log(`\"${text.substring(startOffset, endOffset)}\" -> null3`);\n    return null;\n  } else {\n    let matchedString = text.substring(startOffset, endOffset);\n    // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n    if (dbug) console.log('  returned -> ', [matchedString]);\n    return [matchedString];\n  }\n}\n\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nconst TextTypes = ['Raw', 'STAT', 'AMP'];\n\nexport { getTokens, TextTypes };","\nimport { RiScript } from './riscript.js'\nimport { RiScriptVisitor } from './visitor.js' // 12/13/2023\n\n/**\n * A probabilistic context-free grammar for text-generation, supporting all RiScript\n *  features, including transforms, gates, choices, sequences and assignments.\n * @class RiGrammar\n * @memberof module:riscript\n */\nclass RiGrammar {\n\n  static RiScript = null; // assigned in riscript.js\n\n  /**\n   * Creates an instance of RiGrammar.\n   * @param {Object<string, string>|string} [rules] - an object (or JSON string) containing the rules\n   * @param {Object<string, any>} [context] - the context (or world-state)\n   * @param {Object<string, any>} [options] - options for the grammar\n   */\n  constructor(rules = {}, context = {}, options = {}) {\n\n    /** @type {Object<string, string>} */ this.rules = {};\n    /** @type {Object<string, any>} */ this.context = context;\n    /** @type {RiScript} */ this.scripting = options.RiTa?.riscript ?? new RiScript(options);\n\n    if (typeof rules === 'string') {\n      rules = parseJSON(rules);\n    }\n\n    if (typeof rules !== 'object') {\n      throw Error('RiGrammar: expecting object, found ' + typeof rules);\n    }\n\n    this.setRules(rules);\n  }\n\n  /**\n   * Creates a new RiGrammar from the `rules`, `context` and `options`, then calls `expand()` on it.\n   * @param {string} rules - an object containing the rules\n   * @param {object} [context] - the context (or world-state) for the expansion\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  static expand(rules, context, options) {\n    return new RiGrammar(rules, context).expand(options);\n  }\n\n  /**\n   * Adds a transform to the Grammar instance\n   * @param {string} name - the name of the transform\n   * @param {Function} def - a function that takes a string and returns a string\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addTransform(name, def) {\n    this.scripting.addTransform(name, def);\n    return this;\n  }\n\n  /**\n   * Removes a transform from the Grammar instance\n   * @param {string} name \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeTransform(name) {\n    this.scripting.removeTransform(name);\n    return this;\n  }\n\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return this.scripting.getTransforms();\n  }\n\n  /**\n   * Tests whether two grammars are equal and returns a boolean\n   * @param {RiGrammar} rg - the grammar to compare to \n   * @returns {boolean} - whether the grammars are equal\n   */\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n\n  /**\n   * Expands a grammar from the supplied rule. If no rule is provided the `$start` and `<start>`\n   *  symbols will be checked respectively. If a context is needed, it should be passed when the\n   *  grammar is created.\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  expand(options = {}) {\n    if ('context' in options) {\n      throw Error('pass context to RiScript.grammar() or new RiGrammar() instead');\n    }\n\n    let visitor = new RiScriptVisitor(this.scripting);\n    visitor.context = this.context || {};\n\n    let clonedOpts = { ...options, visitor, input: this._toScript(options) };\n\n    return this.scripting._evaluate(clonedOpts);\n  }\n\n  /**\n   * Validates a rule and adds a new rule to the grammar\n   * @param {string} name - the name of the rule\n   * @param {string} def - the definition of the rule\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n    return this;\n  }\n\n  /**\n   * Sets the rules for the grammar, removing any previous rules\n   * @param {object|string} rules - an object or JSON string holding the rules for the grammar \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  setRules(rules) {\n    if (typeof rules === 'undefined') throw Error('undefined rules');\n    this.rules = {};\n    let incoming = typeof rules === 'string' ? parseJSON(rules) : rules;\n    Object.entries(incoming).forEach((e) => this.addRule(...e));\n    return this;\n  }\n\n  /**\n   * Removes a rule from the grammar\n   * @param {string} name - the name of the rule to remove\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n    return this;\n  }\n\n  /**\n   * Returns a JSON representation of the grammar rules, accepting options from `JSON.stringify()`\n   * @param {any} [replacer] - a replacer function or array\n   * @param {string | number} [space] - the number of spaces to indent\n   * @returns {string} - the JSON representation of the grammar\n   */\n  toJSON(replacer, space) {\n    return JSON.stringify(this.rules, replacer, space);\n  }\n\n  /** \n   * Returns a string representation of the grammar, accecpting the same options as `JSON.stringify()`\n   * @param {object} [options] - options for the string representation\n   * @param {any} [options.replacer] - a replacer function or array\n   * @param {string | number} [options.space] - the number of spaces to indent\n   * @param {string} [options.linebreak] - the linebreak character to use\n   */\n  toString(options = {}) {\n    let replacer = options.replacer || 0;\n    let space = options.space || 2;\n    let lb = options?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb) res = res.replace(/\\n/g, lb);\n    return res;\n  }\n\n  /**\n   * Creates a new RiGrammar from the supplied JSON string\n   * @param {string} json - a JSON string representing the grammar\n   * @param {object} [context] - optional context for the grammar\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  static fromJSON(json, context) {\n    return new RiGrammar(JSON.parse(json), context);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Converts grammar to inline rules; rules are dynamic, unless otherwise specified with leading #\n   * @private\n   */\n  _toScript(opts) {\n\n    let script = '', start = opts.start || 'start';\n\n    let { Symbols } = this.scripting;\n\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      // console.log(i,name);\n      if (!this.scripting.regex.ChoiceWrap.test(rule)) {\n        // let orig = rule;\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n        // console.log('WRAPPING: ' + orig + '->' + rule);\n      }\n      script += `${name}=${rule}\\n`;\n    });\n\n    if (opts.trace) console.log('Grammar:\\n' + script.replace(/^\\$/gm, '  $'));\n\n    script += `${Symbols.DYNAMIC}${start}`;\n\n    return script;\n  }\n\n  /**\n   * Validates a grammar rule\n   * @private\n   */\n  _validateRule(name, def) {\n    if (typeof name !== 'string' || name.length === 0) {\n      throw Error('expected [string] name');\n    }\n\n    if (typeof def === 'undefined') {\n      throw Error('undefined rule def: ' + name);\n    }\n    let { Symbols } = this.scripting;\n\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error('Grammar rules are dynamic by default;' +\n        \" if you need a static rule, use '\" + Symbols.STATIC +\n        name + \"', otherwise just use '\" + name + \"'.\");\n    }\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction parseJSON(json) {\n  if (typeof json === 'string') {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error('RiGrammar appears to be invalid JSON,' +\n        ' please check it at http://jsonlint.com/\\n' + json);\n    }\n  }\n}\n\nexport { RiGrammar };\n"],"mappings":"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","names":["result","Symbol","escapeText","text"]}